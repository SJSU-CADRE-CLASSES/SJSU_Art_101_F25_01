<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Most Googled Diseases</title>
    
    <style>
      body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 24px; color: #111; }
      #container { max-width: 960px; margin: 0 auto; }
      #scene { width: 100%; height: 560px; border: 1px solid #eee; background: linear-gradient(#fafafa, #fff); }
      #tooltip { position: fixed; pointer-events: none; padding: 6px 8px; background: rgba(0,0,0,0.75); color: #fff; border-radius: 4px; font-size: 12px; transform: translate(-50%, -120%); opacity: 0; transition: opacity 0.12s ease; }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="container">
      <h1>Most Googled Diseases</h1>
      <div id="scene"></div>
      <div id="tooltip"></div>
    </div>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

      const labels = ["Flu", "COVID-19", "Diabetes", "Cancer", "Depression", "Anxiety", "Asthma"];
      const values = [78, 95, 62, 70, 54, 59, 48];

      const container = document.getElementById("scene");
      const tooltip = document.getElementById("tooltip");

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(18, 28, 36);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.minDistance = 10;
      controls.maxDistance = 120;
      controls.target.set(0, 10, 0);

      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(20, 40, 10);
      scene.add(dirLight);

      const grid = new THREE.GridHelper(120, 24, 0xdddddd, 0xeeeeee);
      grid.position.y = 0;
      scene.add(grid);

      const group = new THREE.Group();
      scene.add(group);

      const maxValue = Math.max(...values);
      const barWidth = 2.4;
      const barDepth = 2.4;
      const gap = 1.4;
      const xTotal = labels.length * (barWidth + gap) - gap;
      const xStart = -xTotal / 2 + barWidth / 2;

      const bars = [];
      const colorForValue = (v) => {
        const t = v / maxValue; // 0..1
        const color = new THREE.Color();
        color.setHSL(0.58 - 0.58 * t, 0.65, 0.5); // teal -> blue
        return color;
      };

      for (let i = 0; i < labels.length; i++) {
        const value = values[i];
        const height = Math.max(0.5, value * 0.24); // scale 0-100 to ~0-24 units
        const geometry = new THREE.BoxGeometry(barWidth, height, barDepth);
        const material = new THREE.MeshStandardMaterial({ color: colorForValue(value), roughness: 0.5, metalness: 0.1 });
        const bar = new THREE.Mesh(geometry, material);
        bar.position.set(xStart + i * (barWidth + gap), height / 2, 0);
        bar.userData = { label: labels[i], value };
        group.add(bar);
        bars.push(bar);
      }

      // Simple axis line (Y)
      const axisMat = new THREE.LineBasicMaterial({ color: 0x999999 });
      const axisGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 26, 0)
      ]);
      const yAxis = new THREE.Line(axisGeo, axisMat);
      scene.add(yAxis);

      // Raycaster hover for tooltip and highlight
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let hovered = null;

      function onMouseMove(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(bars, false);

        if (intersects.length > 0) {
          const hit = intersects[0].object;
          if (hovered && hovered !== hit) {
            hovered.material.emissive && (hovered.material.emissive.setHex(0x000000));
          }
          hovered = hit;
          if (hovered.material.emissive) hovered.material.emissive.setHex(0x222222);
          tooltip.style.opacity = 1;
          tooltip.textContent = `${hit.userData.label}: ${hit.userData.value}`;
          tooltip.style.left = `${event.clientX}px`;
          tooltip.style.top = `${event.clientY}px`;
        } else {
          if (hovered && hovered.material.emissive) hovered.material.emissive.setHex(0x000000);
          hovered = null;
          tooltip.style.opacity = 0;
        }
      }

      renderer.domElement.addEventListener("mousemove", onMouseMove);

      function onResize() {
        const { clientWidth, clientHeight } = container;
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight);
      }
      window.addEventListener("resize", onResize);

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
  </html>


