<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Playtime Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-image: url("\steam-brain.png");
            background-size: contain;
            min-height: 100vh;
            overflow: hidden;
        }

        .header {
            position: absolute;
            top: 1%;
            left: 1%;
            padding: 1px;
            z-index: 100;
            text-align: center;
        }

        h1 {
            color: white;
            font-size: 1.2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .stats {
            color: rgba(238, 238, 238, 0.9);
            font-size: 1em;
        }

        .controls {
            position: absolute;
            top: 3%;
            right: 2%;
            background: rgba(255, 255, 255, 0.5);
            padding: 2px 5px;
            z-index: 100;
            color: rgb(63, 59, 59);
            text-align: center;
        }

        .control-item {
            font-size: 0.95em;
            margin: 5px 0;
            opacity: 0.9;
        }

        #canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }

        .tooltip {
            position: absolute;
            background: rgba(32, 32, 32, 0.9);
            color: white;
            padding: 5px 8px;
            border-radius: 2px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            font-size: 14px;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1> This is how many hours <br>I've clocked on my steam account</h1>
        <div class="stats">
            Total: <span id="totalGames"></span> games | <span id="totalHours"></span> hours played
        </div>
    </div>

    <canvas id="canvas"></canvas>
    <div class="tooltip" id="tooltip"></div>

    <div class="controls">
        <div class="control-item"><b>Left click</b> to interact <br> <b>Right click</b> to pan view <br> <b>Scroll</b> to zoom</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
        const gameData = [
            { name: "Among Us", hours: 50 },
            { name: "Animal Well", hours: 17 },
            { name: "ANNO Mutationem", hours: 15 },
            { name: "Astroneer", hours: 60 },
            { name: "The Beginners Guide", hours: 14 },
            { name: "Counter Strike", hours: 213 },
            { name: "Crab Game", hours: 33 },
            { name: "Cyberpunk 2077", hours: 95 },
            { name: "Deceit", hours: 14 },
            { name: "Deducto", hours: 7 },
            { name: "A Difficult Game About Climbing", hours: 22 },
            { name: "The Escapists", hours: 8 },
            { name: "Fall Guys", hours: 41 },
            { name: "The Finals", hours: 101 },
            { name: "Foundation", hours: 11 },
            { name: "Friends vs. Friends", hours: 6 },
            { name: "Garry's Mod", hours: 9 },
            { name: "Getting Over It", hours: 20 },
            { name: "Lethal Company", hours: 19 },
            { name: "Mage Arena", hours: 6 },
            { name: "Night at the Gates of Hell", hours: 10 },
            { name: "Omori", hours: 8 },
            { name: "Only Up", hours: 5 },
            { name: "Phasmophobia", hours: 34 },
            { name: "Raft", hours: 18 },
            { name: "Rust", hours: 1472 },
            { name: "Civilization V", hours: 386 },
            { name: "Splitgate", hours: 7 },
            { name: "The Stanley Parable", hours: 7 },
            { name: "Team Fortress 2", hours: 6 },
            { name: "Tiny Terraces", hours: 13 },
            { name: "Vampire Blood Hunt", hours: 24 },
            { name: "VR Chat", hours: 6 }
        ];

        // Stats
        const totalHours = gameData.reduce((sum, game) => sum + game.hours, 0);
        document.getElementById('totalGames').textContent = gameData.length;
        document.getElementById('totalHours').textContent = totalHours.toLocaleString();

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Calculate bubble sizes - using square root for area-based scaling
        const maxHours = Math.max(...gameData.map(g => g.hours));
        const minRadius = 20;
        const maxRadius = 250;

        function calculateRadius(hours) {
            // Use square root to make area proportional to hours
            const sqrtHours = Math.sqrt(hours);
            const sqrtMax = Math.sqrt(maxHours);
            return minRadius + (sqrtMax > 0 ? (sqrtHours / sqrtMax) * (maxRadius - minRadius) : 0);
        }

        // Color palette for games
        const gameColors = {
            "Rust": "#aa2704",
            "Counter Strike": "#ff6b35",
            "Civilization V": "#4a90e2",
            "Cyberpunk 2077": "#00ffff",
            "The Finals": "#ffd700",
            "Astroneer": "#9b59b6",
            "Among Us": "#ff4757",
            "Fall Guys": "#ff6348",
            "Phasmophobia": "#2ecc71",
            "Crab Game": "#e74c3c",
            "Lethal Company": "#34495e",
            "Vampire Blood Hunt": "#8b0000",
            "A Difficult Game About Climbing": "#95a5a6",
            "Getting Over It": "#7f8c8d",
            "Raft": "#3498db",
            "Animal Well": "#27ae60",
            "ANNO Mutationem": "#e056fd",
            "The Beginners Guide": "#bdc3c7",
            "Deceit": "#c0392b",
            "Deducto": "#f39c12",
            "The Escapists": "#d35400",
            "Foundation": "#16a085",
            "Friends vs. Friends": "#ff9ff3",
            "Garry's Mod": "#f368e0",
            "Mage Arena": "#8e44ad",
            "Night at the Gates of Hell": "#2c3e50",
            "Omori": "#ee5a6f",
            "Only Up": "#1abc9c",
            "Splitgate": "#5f27cd",
            "The Stanley Parable": "#f8b739",
            "Team Fortress 2": "#ff7979",
            "Tiny Terraces": "#78e08f",
            "VR Chat": "#4bcffa"
        };

        // Create nodes with physics properties
        const nodes = gameData.map(game => {
            const radius = calculateRadius(game.hours);
            const angle = Math.random() * Math.PI * 2;
            const distance = 100 + Math.random() * 300;
            
            // Make Rust static at center
            const isRust = game.name === "Rust";
            
            return {
                ...game,
                radius: radius,
                x: isRust ? canvas.width / 2 : canvas.width / 2 + Math.cos(angle) * distance,
                y: isRust ? canvas.height / 2 : canvas.height / 2 + Math.sin(angle) * distance,
                vx: isRust ? 0 : -Math.sin(angle) * 0.5,
                vy: isRust ? 0 : Math.cos(angle) * 0.5,
                color: gameColors[game.name] || `hsl(${Math.random() * 360}, 70%, 65%)`,
                static: isRust
            };
        });

        // Camera/zoom variables
        let camera = {
            x: 0,
            y: 0,
            scale: 1
        };

        // Interaction variables
        let draggedNode = null;
        let isDragging = false;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let mouseX = 0;
        let mouseY = 0;

        // Physics simulation with gravity
        function applyForces() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const G = 0.05;

            // Apply gravitational attraction between nodes
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i] === draggedNode || nodes[i].static) continue;
                
                for (let j = 0; j < nodes.length; j++) {
                    if (i === j) continue;
                    
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const distSq = dx * dx + dy * dy;
                    const distance = Math.sqrt(distSq);
                    
                    if (distance > 1) {
                        const force = (G * nodes[j].radius * nodes[j].radius) / distSq;
                        const forceX = (dx / distance) * force;
                        const forceY = (dy / distance) * force;
                        
                        nodes[i].vx += forceX;
                        nodes[i].vy += forceY;
                    }
                }
            }

            // Apply forces between nodes (collision detection)
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = nodes[i].radius + nodes[j].radius;

                    if (distance < minDist && distance > 0) {
                        const angle = Math.atan2(dy, dx);
                        const overlap = minDist - distance;
                        
                        if (nodes[i].static && !nodes[j].static) {
                            nodes[j].x += Math.cos(angle) * overlap;
                            nodes[j].y += Math.sin(angle) * overlap;
                            nodes[j].vx += (dx / distance) * 0.1;
                            nodes[j].vy += (dy / distance) * 0.1;
                        } else if (nodes[j].static && !nodes[i].static) {
                            nodes[i].x -= Math.cos(angle) * overlap;
                            nodes[i].y -= Math.sin(angle) * overlap;
                            nodes[i].vx -= (dx / distance) * 0.1;
                            nodes[i].vy -= (dy / distance) * 0.1;
                        } else if (!nodes[i].static && !nodes[j].static) {
                            const pushX = Math.cos(angle) * overlap * 0.5;
                            const pushY = Math.sin(angle) * overlap * 0.5;

                            nodes[i].x -= pushX;
                            nodes[i].y -= pushY;
                            nodes[j].x += pushX;
                            nodes[j].y += pushY;
                            
                            const mass1 = nodes[i].radius * nodes[i].radius;
                            const mass2 = nodes[j].radius * nodes[j].radius;
                            const totalMass = mass1 + mass2;
                            
                            nodes[i].vx -= (dx / distance) * 0.1 * (mass2 / totalMass);
                            nodes[i].vy -= (dy / distance) * 0.1 * (mass2 / totalMass);
                            nodes[j].vx += (dx / distance) * 0.1 * (mass1 / totalMass);
                            nodes[j].vy += (dy / distance) * 0.1 * (mass1 / totalMass);
                        }
                    }
                }
            }

            // Apply velocity with damping
            nodes.forEach(node => {
                if (node !== draggedNode && !node.static) {
                    node.x += node.vx;
                    node.y += node.vy;
                    node.vx *= 0.98;
                    node.vy *= 0.98;
                }
            });
        }

        // Draw function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.scale, camera.scale);

            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                ctx.fillStyle = node.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const fontSize = Math.max(12, node.radius / 3);
                ctx.font = `bold ${fontSize}px 'Segoe UI', sans-serif`;
                ctx.fillText(`${node.hours}h`, node.x, node.y);
            });

            ctx.restore();
        }

        // Animation loop
        function animate() {
            applyForces();
            draw();
            requestAnimationFrame(animate);
        }
        animate();

        // Mouse/touch interaction
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: (clientX - rect.left - camera.x) / camera.scale,
                y: (clientY - rect.top - camera.y) / camera.scale
            };
        }

        function getNodeAtPosition(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                const dx = x - node.x;
                const dy = y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < node.radius) {
                    return node;
                }
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                e.preventDefault();
                isPanning = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'move';
                return;
            }
            
            if (e.button === 0) {
                const pos = getMousePos(e);
                draggedNode = getNodeAtPosition(pos.x, pos.y);
                
                if (draggedNode) {
                    isDragging = true;
                    canvas.style.cursor = 'grabbing';
                }
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            mouseX = pos.x;
            mouseY = pos.y;

            if (isDragging && draggedNode) {
                draggedNode.x = pos.x;
                draggedNode.y = pos.y;
                draggedNode.vx = 0;
                draggedNode.vy = 0;
                tooltip.style.opacity = '0';
            } else if (isPanning) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                camera.x += dx;
                camera.y += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                tooltip.style.opacity = '0';
            } else {
                const hoveredNode = getNodeAtPosition(pos.x, pos.y);
                if (hoveredNode) {
                    canvas.style.cursor = 'grab';
                    tooltip.textContent = `${hoveredNode.name} - ${hoveredNode.hours} hours`;
                    tooltip.style.left = e.clientX + 15 + 'px';
                    tooltip.style.top = e.clientY + 15 + 'px';
                    tooltip.style.opacity = '1';
                } else {
                    canvas.style.cursor = 'default';
                    tooltip.style.opacity = '0';
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedNode = null;
            isDragging = false;
            isPanning = false;
            canvas.style.cursor = 'default';
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = camera.scale * delta;
            
            if (newScale >= 0.3 && newScale <= 3) {
                const mouseX = e.clientX - canvas.width / 2;
                const mouseY = e.clientY - canvas.height / 2;
                
                camera.x -= mouseX * (delta - 1);
                camera.y -= mouseY * (delta - 1);
                camera.scale = newScale;
            }
        });
    </script>
</body>
</html>